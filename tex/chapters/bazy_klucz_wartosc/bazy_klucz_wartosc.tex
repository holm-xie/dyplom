\chapter{Bazy Klucz-Wartość}

\section*{Streszczenie}
W tym rozdziale opisane zostaną dwie bazy klucz-wartość: Redis i Riak.
\todo{Rozszerzyć wstęp}

\section{Redis}
\label{sec:redis}

\subsection*{Wstęp} 

Redis jest jedną z najbardziej popularnych baz NoSQL.
Swoją popularność zawdzięcza on niezwykle bogatemu jak na bazę typu klucz-wartość API, oraz bardzo dużej wydajności\footnote{Wraz z instalacją systemu dostępne jest narzędzie redis-benchmark, które to dla komputera klasy PC pokazało wydajność ponad 140 tysięcy operacji GET i SET na sekundę.}.
Bardzo często system ten jest wykorzystywany w aplikacjach internetowych równolegle z relacyjnymi bazami danych, najczęściej jako kolejka zadań albo w zastępstwie Memcached jako cache oraz baza, w której przechowywana jest sesja użytkownika.

Mimo, że jest on klasyfikowany jako baza typu klucz-wartość, Redis nie jest horyzontalnie skalowalny.
Nie jest to zazwyczaj bardzo dużym problemem, ponieważ Redis jest w większości przypadków wystarczająco wydajny aby jeden węzeł był w stanie obsłużyć wszystkie zapytania generowane przez aplikację.

\subsection*{Protokół komunikacji}

Redis używa bardzo prostego, tekstowego protokołu komunikacji.
Istnieje możliwość autentykacji, ale tylko przy pomocy hasła zapisanego w konfiguracji serwera.
Nie ma możliwości tworzenia wielu użytkowników i określania ich uprawnień.
Ponieważ hasło jest przesyłane otwartym tekstem, a połączenia nie są w żaden sposób szyfrowane, Redis nie należy do najbezpieczniejszych rozwiązań na rynku.

Dzięki prostemu protokołowi, biblioteki do komunikacji z tym systemem są dostępne praktycznie dla każdego języka programowania.
Dla niektórych języków programowania dostępne są także biblioteki wyższego poziomu, które pełnią rolę bardzo podobną do bibliotek ORM (Object-Relational Mapping).
Biblioteki takie jak Ohm dla języka Ruby pozwalają na mapowanie obiektów na strukturę kluczy w Redis, włącznie z indeksowaniem wartości niektórych pól, co umożliwia wyszukiwanie rekordów po czym innym niż wartość klucza. 

\subsection*{Replikacja}

Redis posiada mechanizm replikacji w trybie master-slave.
Replikacja jest asynchroniczna, co oznacza, że dane odczytane z serwerów slave mogą być czasem nieaktualne.
Często Redis jest konfigurowany w taki sposób, aby serwer master w ogóle nie dokonywał zapisów na dysk twardy, tylko pozostawiał tą rolę serwerowi lub serwerom slave.
Rozwiązanie takie pozwala na zwiększenie wydajności.

\subsection*{Partycjonowanie}

Redis nie obsługuje partycjonowania w wersji 2.0.
Niektóre biblioteki pozwalają wprawdzie na implementację partycjonowania po stronie klienta, ale są to bardzo prymitywne rozwiązania, które nie mogą w żaden sposób konkurować z partycjonowaniem po stronie serwera, jakie jest zaimplementowane np. w omawianym w kolejnym rozdziale systemie Riak.

W przypadku systemów typu klucz-wartość samodzielna implementacja partycjonowania i replikacji kluczy jest zazwyczaj najprostsza z pośród wszystkich typów nierelacyjnych baz danych.
Redis jednak obsługuje złożone typy danych, których wielkość dla pojedynczego klucza może potencjalnie przekroczyć wielkość dostępnej pamięci RAM, a których nie da się w żaden prosty sposób podzielić na wiele węzłów.
Dlatego dopóki nie zostanie zaimplementowany \emph{Redis Cluster}, systemowi temu będzie daleko do konkurencji pod względem skalowalności.

\subsubsection*{Redis Cluster}

W planach jest implementacja tak zwanego \emph{Redis Cluster}, który pozwoli na horyzontalne skalowanie systemu poprzez replikację i partycjonowanie danych.
Redis Cluster będzie systemem typu CA (Consistent-Available).
W systemie będą występować cztery rodzaje węzłów:

\begin{description}
 \item[Data Node] (węzeł danych) - węzły przechowujące dane.
 Skalowanie systemu odbywa się poprzez zwiększanie liczby tych węzłów.

 \item[Configuration Node] (węzeł konfiguracyjny) - węzeł przechowujący metadane o całym systemie, takie jak listy \emph{Data Node} i \emph{Proxy Node}.
 W razie awarii tego węzła, system wprawdzie nie zaprzestaje normalnej pracy, ale nie jest w stanie obsłużyć sytuacji wyjątkowych takich jak awaria innego węzła.
 Ten węzeł tylko przechowuje dane konfiguracyjne, węzłem odpowiedzialnym za ich obsługę jest \emph{Handling Node}.

 \item[Proxy Node] (węzeł proxy) - węzły odpowiedzialne za koordynację zapytań w systemie.
 Zapytania w systemie są zawsze kierowane do węzłów Proxy, które przekazują je następnie do jednego (w przypadku odczytów) lub wszystkich (w przypadku operacji zmieniających dane) węzłów, na których odpowiednie rekordy są zapisane.
 Awarie są wykrywane przez \emph{Proxy Node} i informacja o nich jest zapisywana w węźle konfiguracyjnym.

 \item[Handling Node] (węzeł zarządzający) - to klient, który obsługuje dane zapisane w węźle konfiguracyjnym.
 Zajmuje się on zmianą przydziału zakresów kluczy do węzłów w razie dodania lub usunięcia węzła, lub jego awarii.
 Najczęściej \emph{Handling Node} i \emph{Configuration Node} powinny być umieszczone na tym samym fizycznym węźle.
\end{description}

\subsection*{Persystencja}

\subsubsection*{Snapshotting}

Redis zawdzięcza swoją szybkość temu, że zarówno operacje zapisu, jak i operacje odczytu nie muszą operować na danych zapisanych na dysku twardym, tylko na danych w pamięci RAM.
Domyślnie Redis pracuje w trybie zapisywania zrzutów aktualnego stanu (ang. \emph{snapshotting}) co pewien czas w zależności od liczby wykonanych operacji.
Typową konfiguracją w tej opcji jest zapis danych na dysk co 60 sekund jeżeli zostało dokonanych przynajmniej 100 zmian, albo do 1000 sekund, jeżeli została wykonana co najmniej jedna zmiana.

\subsubsection*{Append Only File}

Alternatywą dla periodycznego zrzucania stanu bazy na dysk jest \emph{Append Only File} (plik tylko do dopisywania).
Technika ta polega na dopisywaniu zmian w bazie na koniec pliku, przypominającego dziennik transakcji.
Przy starcie systemu plik ten jest odczytywany i zmiany w nim zawarte są aplikowane po kolei aby przywrócić stan bazy.
Oczywiście plik ten rośnie z czasem, co powoduje także wydłużenie czasu startu systemu, dlatego dostępna jest komenda służąca do przepisania pliku z postaci dziennika do postaci zrzutu bazy - pozwala to zaoszczędzić miejsce na dysku i znacznie przyspieszyć start systemu.

W przypadku \emph{Append Only File} domyślnie dane są zapisywane na dysk co sekundę przy pomocy wywołania systemowego \verb+fsync()+, które gwarantuje że dane zostaną zapisane na dysku.
Alternatywnie możliwe jest wywołanie \verb+fsync()+ po każdej modyfikującej operacji, ale obija się to tak bardzo negatywnie na wydajności, że nie jest to zalecana konfiguracja.
Można także skonfigurować Redis tak, aby nigdy sam nie dokonywał operacji \verb+fsync()+ i powierzył odpowiedzialność za regularne zapisywanie danych na dysk systemowi operacyjnemu, co zwiększa wydajność kosztem bezpieczeństwa danych.

\subsection*{Wersjonowanie}

Redis nie posiada mechanizmu wersjonowania rekordów - dla klucza jest przechowywana tylko jego aktualna wartość i nie ma identyfikatorów wersji.
System ten jednak obsługuje transakcje (operacja \verb+MULTI+) oraz komendę \verb+WATCH+, które pozwalają na uniknięcie przypadkowego nadpisania rekordu.

\subsubsection*{Zmiana rekordu bez użycia MULTI i WATCH}

\begin{enumerate}
 \item Klienci A oraz B odczytują wartość klucza (\verb+GET nazwa_klucza+)
 \item Klienci A oraz B przetwarzają otrzymaną wartość klucza i zmienia ją
 \item Klient A zapisuje nową wartość dla klucza (\verb+SET nazwa_klucza nowa_wartosc1+)
 \item Klient B zapisuje nową wartość dla klucza (\verb+SET nazwa_klucza nowa_wartosc2+) nadpisując tym samym zmiany dokonane przez klienta A.
\end{enumerate}

\subsubsection*{Zmiana rekordu z użyciem transakcji}

\begin{enumerate}
 \item Klienci A oraz B oznaczają klucz jako obserwowany (\verb+WATCH nazwa_klucza+)
 \item Klienci A oraz B odczytują wartość klucza (\verb+GET nazwa_klucza+)
 \item Klienci A oraz B przetwarzają otrzymaną wartość klucza i zmienia ją
 \item Klienci A oraz B rozpoczynają transakcję w celu zapisania nowej wartości (\verb+MULTI+)
 \item Klient A zapisuje nową wartość dla klucza (\verb+SET nazwa_klucza nowa_wartosc1+)
 \item Klient B zapisuje nową wartość dla klucza (\verb+SET nazwa_klucza nowa_wartosc2+)
 \item Klient A kończy transakcję (\verb+EXEC+) - transakcja kończy się powodzeniem
 \item Klient B kończy transakcję (\verb+EXEC+) - transakcja kończy się niepowodzeniem, ponieważ klient A zmodyfikował obserwowany klucz.
 Zmiana dokonana przez klienta B jest wycofana.
 \item Klient B musi wykonać całą operację od początku, odczytując tym samym wartość zapisaną przez klienta A.
\end{enumerate}

\subsection*{Wyszukiwanie}

Redis implementuje operacje na kilku różnych strukturach danych.
Wyróżnia go to spośród innych systemów typu klucz-wartość, sprawiając że jest on tym samym o wiele łatwiejszy w użyciu i wymaga mniej pracy od programisty.

Podobnie jak inne systemy typu klucz-wartość Redis nie udostępnia możliwości indeksowania zapisanych wartości, ale samodzielne tworzenie takich indeksów jest nieco ułatwione dzięki istnieniu takich struktur danych jak zbiór czy lista.

\subsubsection*{Obsługiwane struktury danych}

\begin{description}
 \item[Ciąg znaków] - jest to podstawowa struktura danych.
 Dostępne są między innymi operacje odczytujące i zapisujące wartość dla klucza, oraz (nietypowo) operacje pozwalające na dopisanie ciągu znaków na koniec klucza oraz na odczytanie jedynie jego fragmentu.
 Możliwe jest także określenie czasu życia klucza, po którym może on zostać przez system usunięty.

 \item[Lista] - pozwala na zapisanie sekwencji wartości.
 Możliwe jest atomowe dodanie wartości na początek bądź koniec listy oraz atomowe pobranie wartości z początku lub końca.
 Dostępna jest także blokująca wersja pobrania wartości.
 Listy są bardzo przydatne do implementacji kolejek zadań.
 Stosuje się je także do łączenia wielu rekordów w kolekcje (zapisując ich klucze na liście), ale warto pamiętać, że stronicowanie takiego zbioru ma złożoność liniową do wielkości listy, więc powinno się go raczej unikać.

 \item[Zbiór] - umożliwia wykonywania operacji na zbiorach (sprawdzenie członkostwa elementu, suma, przecięcie, różnica).
 Możliwe jest pobranie jednego, losowego elementu, albo wszystkich elementów zbioru.

 \item[Posortowany Zbiór] - umożliwia zapisanie posortowanej sekwencji wartości.
 Możliwe jest wykonanie przecięcia i sumy, ale nie różnicy posortowanych zbiorów.
 Możliwe jest także, podobnie jak dla list, stronicowanie zbioru.

 \item[Tablica mieszająca] - często rekordy w Redisie są zapisywane w taki sposób, że kluczowi identyfikującemu rekord przypisujemy wartość, którą jest obiekt, zserializowany, np. do formatu JSON.
 Jest to akceptowalne, jeżeli zawsze chcemy odczytywać rekordy w całości, ale jeżeli rekord jest duży, a potrzebne jest nam tylko kilka jego pól, to lepiej każde z nich zapisać pod osobnym kluczem.
 Tablica mieszająca jest strukturą, która optymalizuje właśnie to zastosowanie.
\end{description}

\subsection*{Unikalne cechy}

Redis posiada wiele funkcjonalności, które go wyróżniają na tle innych systemów typu klucz-wartość.
Wśród nich poczesne miejsce zajmuje na pewno opisana wcześniej obsługa różnych typów danych, ale można do nich zaliczyć także mechanizm obsługi zdarzeń (Publish-Subscribe) oraz implementacja pamięci wirtualnej wewnątrz systemu, bez polegania na funkcjonalności systemu operacyjnego.

\subsubsection*{Publish-Subscribe}

W ostatnich latach aplikacje internetowe coraz częściej uaktualniają zawartość strony bez potrzeby odświeżenia jej przez użytkownika.
Często potrzebne jest aby takie aktualizacje były dostarczane do klienta w czasie niemal rzeczywistym (na przykład Google Wave pokazuje użytkownikowi tekst wpisywany przez innych użytkowników litera po literze).
W takich przypadkach mechanizm obsługi zdarzeń ma największe zastosowanie.
Mechanizm ten, nazywany również wzorcem Publish-Subscribe, polega na tym, że klienci mogą zapisywać się na otrzymywanie zdarzeń publikowanych w określonych kanałach.
Dzięki istnieniu takich kanałów, zapisani na zdarzenia nie muszą wiedzieć o publikujących i vice versa.
Natomiast dzięki temu, że zapisani na zdarzenia są o ich zajściu informowani bezpośrednio po fakcie, nie jest konieczne regularne odpytywanie serwera, co zmniejsza jego obciążenie, oraz skraca okres czasu pomiędzy zajściem zdarzenia a pokazaniem jego efektów użytkownikowi.

\subsubsection*{Pamięć Wirtualna}

Redis jest przeznaczony do pracy ze zbiorami danych, które w całości mieszczą się w pamięci operacyjnej serwera.
Ponieważ jednak w rzeczywistości często występują zbiory danych, których nie da się zmieścić w pamięci RAM, ale których niektóre fragmenty są odczytywane i zapisywane dużo częściej niż inne, Redis implementuje własną wersję pamięci wirtualnej.

Bardzo często pada pytanie dlaczego Redis implementuje coś, co jest już zaimplementowane w systemie operacyjnym.
Szeroko odpowiada na to artykuł na blogu autora tej bazy \cite{antirez-redis-vm}.
Jedną z zalet własnej implementacji jest to, że pozwala to na stronicowanie na poziomie rekordów, podczas gdy system operacyjny operuje na poziomie stron pamięci, które mogą zawierać zarówno często, jak i rzadko używane rekordy.
Inną zaletą jest to, że rekord zapisany na dysku nie musi mieć identycznej postaci jak w pamięci.
Poprzez nie zapisywanie metadanych i różnych wskaźników, zapisywane rekordy mogą zajmować na dysku 10 razy mniej miejsca niż w pamięci operacyjnej.
Zaletą nie wymienioną przez autora jest to, że kiedy korzystamy z wirtualnej pamięci, ustalony zostaje maksymalny rozmiar pamięci zajmowanej przez system\footnote{Opcja ta może być włączona także bez włączania pamięci wirtualnej, ale włączenie jej w takiej sytuacji może prowadzić do zrywania połączeń z klientami a nawet utraty danych.}.
Dzięki temu Redis może koegzystować na jednej maszynie z innymi aplikacjami takimi jak serwer aplikacyjny i nie konkurować z nimi o RAM.

\subsection*{Typowe zastosowania}

Dzięki temu, że Redis posiada obsługę list z atomową i blokującą operacją pobrania pierwszego lub ostatniego elementu listy, system ten jest powszechnie wykorzystywany do przechowywania kolejek zadań.
Wykorzystując posortowane zbiory i mechanizm opisany w sekcji ,,Wersjonowanie'', możliwa jest także implementacja kolejek priorytetowych.

Ze względu na bardzo dużą wydajność oraz możliwość określania czasu życia kluczy Redis jest także wykorzystywany często jako cache dla aplikacji internetowych.

Redis nie jest często wykorzystywany jako podstawowa baza danych, ale zdobył on popularność wśród twórców gier internetowych, gdzie jego stosunkowo prosty model danych nie jest przeszkodą, a wydajność jest bardzo dużą zaletą.

\subsection*{Przeciwwskazania}

Redis został stworzony z myślą o zbiorach danych, które można pomieścić w pamięci operacyjnej serwera, dlatego (mimo istnienia pamięci wirtualnej) nie jest zalecane stosowanie tego systemu w połączeniu z bardzo dużymi zbiorami danych.
Jedną z podstawowych zalet tego systemu jest duża wydajność, którą traci on całkowicie jeżeli zastosowany zostanie Append Only File z opcją zapisu na dysk po każdej transakcji.
W związku z tym, jeżeli ryzyko utraty danych z ostatniej sekundy przed awarią jest nie do przyjęcia, Redis nie jest najlepszym rozwiązaniem w takim przypadku.

\subsection*{Dokumentacja i wsparcie}

Dokumentacja Redisa jest na bardzo wysokim poziomie.
Każda komenda jest dobrze opisana (włączając w to opis złożoności obliczeniowej), a ponadto rozwiązania takie jak transakcje, Publish-Subscribe czy pamięć wirtualna są opisane w osobnych artykułach, najczęściej z przykładami.
W internecie można znaleźć wiele przykładów zastosowania Redisa i bibliotek na licencji open source, które z niego korzystają, co ułatwia lepsze poznanie tego systemu.

Redis został stworzony i jest rozwijany przez Salvatore Sanfilippo, a od niedawna jego rozwój jest sponsorowany przez firmę VMWare.

\subsection*{Pomocne odnośniki}
 
Poniżej zamieszczono kilka odnośników do stron WWW związanych z Redisem.

\begin{description}
 \item [http://code.google.com/p/redis/] - strona domowa projektu
 \item [http://code.google.com/p/redis/wiki/CommandReference] - spis wszystkich komend
 \item [http://retwis.antirez.com/] - klon Twittera korzystający z Redisa
 \item [http://ohm.keyvalue.org/] - strona domowa biblioteki Ohm (odpowiednik ORM dla Redisa)
 \item [http://www.rediscookbook.org/] - Redis Cookbook, opis rozwiązań niektórych typowych problemów
 \item [https://github.com/defunkt/resque] - popularna implementacja kolejki zadań stworzona na potrzeby serwisu GitHub
\end{description}

\section{Riak}
\label{sec:riak}

\subsection*{Wstęp} 

Wstęp

\subsection*{Protokół komunikacji}

Protokół komunikacji

\subsection*{Replikacja}

Replikacja

\subsection*{Partycjonowanie}

Partycjonowanie

\subsection*{Persystencja}

Persystencja

\subsection*{Wersjonowanie}

Wersjonowanie

\subsection*{Wyszukiwanie}

Wyszukiwanie

\subsection*{Unikalne cechy}

Unikalne cechy

\subsection*{Typowe zastosowania}

Typowe zastosowania

\subsection*{Przeciwwskazania}

Przeciwwskazania

\subsection*{Dokumentacja i wsparcie}

Dokumentacja i wsparcie

\subsection*{Pomocne odnośniki}
 
Pomocne odnośniki